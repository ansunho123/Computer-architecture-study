# Branch Predictor ê³¼ì œ (Computer Architecture 2023)

## **1. ê°œìš”**
ì´ í”„ë¡œì íŠ¸ëŠ” **ë¸Œëœì¹˜ ì˜ˆì¸¡ê¸°(Branch Predictor)**ë¥¼ ì„¤ê³„í•˜ê³  êµ¬í˜„í•˜ëŠ” ê³¼ì œì…ë‹ˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ 1-bit predictorê°€ ì œê³µë˜ì—ˆìœ¼ë©°, ì´ë¥¼ ê°œì„ í•˜ì—¬ **ë” ë†’ì€ ì •í™•ë„ë¥¼ ê°–ëŠ” ì˜ˆì¸¡ê¸°ë¥¼ ê°œë°œ**í•˜ëŠ” ê²ƒì´ ëª©í‘œì…ë‹ˆë‹¤.

ë³¸ í”„ë¡œì íŠ¸ì—ì„œëŠ” **2-bit Saturating Counter**ë¥¼ í™œìš©í•œ ì˜ˆì¸¡ê¸°ë¥¼ êµ¬í˜„í•˜ì˜€ìœ¼ë©°, ì´ë¥¼ í†µí•´ ë¸Œëœì¹˜ ì˜ˆì¸¡ ì„±ëŠ¥ì„ ë†’ì˜€ìŠµë‹ˆë‹¤.

---

## **2. Branch Predictorë€?**
**Branch Predictor(ë¸Œëœì¹˜ ì˜ˆì¸¡ê¸°)**ëŠ” CPUê°€ ë¶„ê¸°(Branch) ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•  ë•Œ **í•´ë‹¹ ë¶„ê¸°ê°€ Taken(ì‹¤í–‰ë¨)ì¸ì§€ Not Taken(ì‹¤í–‰ë˜ì§€ ì•ŠìŒ)ì¸ì§€ ì˜ˆì¸¡**í•˜ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤.

ë¸Œëœì¹˜ ì˜ˆì¸¡ì´ ì¤‘ìš”í•œ ì´ìœ ëŠ” **íŒŒì´í”„ë¼ì¸ ì„±ëŠ¥ í–¥ìƒ**ì„ ìœ„í•´ ë¯¸ë¦¬ ì˜ˆì¸¡ì„ ìˆ˜í–‰í•˜ì—¬ ë¶ˆí•„ìš”í•œ ì‹¤í–‰ ì§€ì—°ì„ ì¤„ì´ê¸° ìœ„í•¨ì…ë‹ˆë‹¤.

### **ğŸ“Œ 2-bit Saturating Counter ë°©ì‹**
1. **ê° ë¸Œëœì¹˜ ëª…ë ¹ì–´ì— ëŒ€í•´ 2-bit ìƒíƒœ ê°’ì„ ì €ì¥** (0, 1, 2, 3)
2. **ê°’ì´ 2 ì´ìƒì´ë©´ Taken(1)ìœ¼ë¡œ ì˜ˆì¸¡, 2 ë¯¸ë§Œì´ë©´ Not Taken(0)ìœ¼ë¡œ ì˜ˆì¸¡**
3. ì˜ˆì¸¡ì´ í‹€ë¦´ ê²½ìš° ìƒíƒœ ê°’ì„ ì¦ê°€(ë˜ëŠ” ê°ì†Œ)ì‹œì¼œ **í•™ìŠµ**

---

## **3. ì‹¤í–‰ ë°©ë²• (Build & Run Instructions)**
### **ğŸ”¹ Linux & Mac**
```bash
(in target directory)
mkdir build && cd build
cmake ..
make
```
ë¹Œë“œ í›„ ì‹¤í–‰ íŒŒì¼ì´ **release ë””ë ‰í† ë¦¬**ì— ìƒì„±ë©ë‹ˆë‹¤.

ì‹¤í–‰ ê²°ê³¼ë¥¼ í™•ì¸í•˜ë ¤ë©´ ë‹¤ìŒ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”:
```bash
./predictor_main
```
ë¹Œë“œ ê²°ê³¼ ì‚­ì œ:
```bash
make clean
```

### **ğŸ”¹ Windows**
ê³¼ì œì— ì²¨ë¶€ëœ ë¬¸ì„œë¥¼ ì°¸ê³ í•˜ì—¬ CMakeë¥¼ í†µí•´ ë¹Œë“œí•˜ì„¸ìš”.

---

## **4. êµ¬í˜„í•œ ì˜ˆì¸¡ê¸° ì„¤ëª… (2-bit Predictor)**

### **ğŸ“Œ ì˜ˆì¸¡ í•¨ìˆ˜ (`get_pred`)**
```cpp
int your_own::get_pred(int pc)
{
  int idx = pc % num_predictor_entry;
  int prediction = pred_arr[idx];
  if (prediction >= 2)
  {
    prediction = 1;
  }
  else
  {
    prediction = 0;
  }
  return prediction;
}
```
- **PC ê°’ì„ í•´ì‹œ ì²˜ë¦¬í•˜ì—¬ í…Œì´ë¸” ì¸ë±ìŠ¤ ê³„ì‚°** (`pc % num_predictor_entry`)
- í•´ë‹¹ ì¸ë±ìŠ¤ì˜ 2-bit ê°’ì„ í™•ì¸í•˜ì—¬ ì˜ˆì¸¡ ìˆ˜í–‰
  - ê°’ì´ `2 ì´ìƒ`ì´ë©´ **Taken(1)**
  - ê°’ì´ `1 ì´í•˜`ì´ë©´ **Not Taken(0)**

### **ğŸ“Œ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (`update`)**
```cpp
void your_own::update(int pc, int res)
{
  int idx = pc % num_predictor_entry;
  int *arr = pred_arr;
  int prediction = pred_arr[idx];
  if (res == 1)
  {
    if (prediction < 3)
    {
      arr[idx]++;
    }
    else
    {
      arr[idx] = 3;
    }
  }
  else
  {
    if (prediction != 0)
    {
      arr[idx]--;
    }
    else
    {
      arr[idx] = 0;
    }
  }
}
```
- **ì˜ˆì¸¡ ê²°ê³¼(res)ì— ë”°ë¼ ì¹´ìš´í„° ì—…ë°ì´íŠ¸**
  - **Taken(1)ì¼ ê²½ìš° â†’ ê°’ì„ ì¦ê°€** (ìµœëŒ€ `3`ê¹Œì§€)
  - **Not Taken(0)ì¼ ê²½ìš° â†’ ê°’ì„ ê°ì†Œ** (ìµœì†Œ `0`ê¹Œì§€)
  - ì¦‰, í¬í™” ì¹´ìš´í„°(Saturating Counter)ë¡œ ë™ì‘í•˜ì—¬ **ë„ˆë¬´ ì‰½ê²Œ ë³€í™”í•˜ì§€ ì•Šë„ë¡ ì„¤ê³„**

---

## **5. ì‹¤í–‰ ê²°ê³¼ ì˜ˆì‹œ**
```bash
total : 10000 branch, correct : 8500 , ratio : 85.0%
```
- `total` : ì „ì²´ ë¸Œëœì¹˜ ê°œìˆ˜
- `correct` : ë§íŒ ì˜ˆì¸¡ ê°œìˆ˜
- `ratio` : ì˜ˆì¸¡ ì •í™•ë„ (%)

---

## **6. ê²°ë¡  ë° ê°œì„ ì **
### **ğŸ”¹ ì¥ì **
- **1-bit predictorë³´ë‹¤ í–¥ìƒëœ ì •í™•ë„ ì œê³µ**
- ê°„ë‹¨í•œ êµ¬í˜„ ë°©ì‹ìœ¼ë¡œë„ **ë¹„êµì  ë†’ì€ ì˜ˆì¸¡ ì„±ëŠ¥ì„ ë³´ì„**
- ì‹¤ì œ CPUì—ì„œë„ ì‚¬ìš©ë˜ëŠ” **2-bit predictor ë°©ì‹**ì„ ì ìš©

### **ğŸ”¹ ê°œì„  ê°€ëŠ¥ì **
- **Global History ì‚¬ìš©** â†’ ë” ì •êµí•œ ì˜ˆì¸¡ ê°€ëŠ¥
- **Tournament Predictor** â†’ ë‹¤ì–‘í•œ ë°©ì‹ ì¡°í•©í•˜ì—¬ ë” ë†’ì€ ì„±ëŠ¥
- **Perceptron Branch Predictor** â†’ ì‹ ê²½ë§ ê¸°ë°˜ ì˜ˆì¸¡ ê°€ëŠ¥

---

## **7. ì°¸ê³  ìë£Œ**
- "Computer Architecture: A Quantitative Approach" - John L. Hennessy, David A. Patterson
- SPEC CPU2006 ë²¤ì¹˜ë§ˆí¬ ê³µì‹ ë¬¸ì„œ
- ê³¼ì œ ì œê³µ ë¬¸ì„œ

---

ì´ í”„ë¡œì íŠ¸ëŠ” ê¸°ë³¸ì ì¸ 2-bit branch predictorë¥¼ êµ¬í˜„í•˜ëŠ” ì‹¤ìŠµì´ì—ˆìœ¼ë©°, ì´ë¥¼ í™•ì¥í•˜ì—¬ ë‹¤ì–‘í•œ ì˜ˆì¸¡ ê¸°ë²•ì„ ì—°êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ğŸš€

